## Module: Phoenix Talon CVE 2017-8890

This may resolve issue [#8571](https://github.com/rapid7/metasploit-framework/issues/8571), which requests Phoenix Talon modules.

## Overview of 2017-8890

[This CVE:](https://nvd.nist.gov/vuln/detail/CVE-2017-8890)
- is the most serious member of the Phoenix Talon class of Linux kernel vulnerabilities. No POC of this CVE exists in the [Exploit DB](https://www.exploit-db.com/search?verified=true&hasapp=true&nomsf=true). But other public POC's are available.
- is not very well-documented. But here's a [short explanation](https://2freeman.github.io/2018/01/06/CVE-2017-8890-internals.html) to give you a general understanding of the vulnerability.
- exists in all kernel versions through 4.10.15, although some sources say it exists through 4.11. [See the patch commit here](https://github.com/torvalds/linux/commit/657831ffc38e30092a2d5f03d385d710eb88b09a).
- is the result of a flaw in the kernel's IPv4 stack (specifically, multicast).

On the target machine, a double-free is triggered due to the kernel keeping an extra copy of `mc_list` at `accept()` time.

#### Pseudocode with explanations:

Thanks to GitHub user beraphin, who made his POC public [here](https://github.com/beraphin/CVE-2017-8890) and explained his approach nicely [here](http://eternalsakura13.com/2018/04/14/cve-2017-8890/).

A machine running a kernel 4.11 and under is at risk if it is running the following routine:
```
sockfd = socket(AF_INET, xx, IPPROTO_TCP);
setsockopt(sockfd, SOL_IP, MCAST_JOIN_GROUP, xxxx, xxxx);
bind(sockfd, xxxx, xxxx);
listen(sockfd, xxxx);
newsockfd = accept(sockfd, xxxx, xxxx);
close(newsockfd);  // trigger release calls, handoff to RCU
sleep(5);          // wait for rcu to free()
close(sockfd);     // second free()
```

The parent socket, `sockfd`, is created. It is added to the multicast group with option MCAST_JOIN_GROUP.
In adding the socket to the multicast group on the local interface, the kernel allocates memory. At this point,
`mc_list` exists in the parent socket.

After an address is assigned to the socket with `bind()`, `listen()` for the connection and `accept()`.
`accept()` creates a new socket, `newsockfd`, to which all necessary fields of the parent are copied, 
including the value of the `mc_list` pointer. At this point, there are multiple pointers pointing
to the same block of memory, hence the double free.

When the connection is established, the kernel creates a child socket that inherits the `mc_list` object of the parent socket.
This inheritence flaw is in the `inet_csk_clone_lock` in line 648 of file [net/ipv4/inet_connection_sock.c](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/ipv4/inet_connection_sock.c?h=v4.9-rc5).
View [the patch](https://github.com/torvalds/linux/commit/657831ffc38e30092a2d5f03d385d710eb88b09a) to see the one-line fix for this unintended inheritence.

Next, close the child socket. As explained above, this does not release the `mc_list` object.
It goes through the RCU (remote-copy-update) structure to release memory.
`sleep()` for a few seconds to make sure the RCU handoff has enough time to call `kfree()`.
Finally, close the parent socket, which will trigger the second free.


## The Module

Being a kernel-level double-free vulnerability that can be triggered over the network,
 this CVE has potential for high-risk exploits. This module features two exploits:
 1. Simple DoS. Remotely trigger double-free on known target machine running the requesite server routine (explained above). This carries consequences such as possible kernel panic and arbitrary code execution.
 2. Privilege elevation by heap spray. Run requesite server routine + privilege-elevation code on accessible target machine. 
 
TODO: #1: Very feasible in ruby since all we have to do is act as a client. But it'd be nice to send some info back to client. How does the client (MSF user) know if the connection was accepted? Is there some sort of callback or notifier we can capture? 
      #2: Is there a way to do this in MSF? These really need to be remote exploits (server is a different machine). We obviously don't want a local MSF machine to get nuked.
	We have C code up and ready. Maybe we can do the ole social engineering trick and compile an executable (use MSFVenom? Similar to how reverse tcp works?), and place it on the target machine.
	Then, the target machine is runnig the server + permission escalation code. Next, we can basically perform #1 again (act as remote client, get accept() -> double free -> heap spray -> escalate privileges.
	Again, it'd be ideal to get some sort of report back to the MSF user (client) after the remote heap spray works, and root is actually begotten for the user (I believe our code currently adds the user to the root group).
	Once root is begotten, we can use reverse TCP shell and show that we can execute commands as root.
